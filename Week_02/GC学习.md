# GC 学习

## 什么时 GC
GC（垃圾收集， Garbage Collection ），不是一个Java独有的概念，在计算机历史上出现的时间比Java早很多。
Java语言来自于C++，在C++中，每个程序员就如同上帝一样，管理自己所需要的内存（申请，释放等），但是一旦程序员忘记了（当程序比较复杂时，就会经常发生），就可能造成资源浪费甚至内存泄露。
Java 吸取了C++的经验，又要避免犯同样的错误，不由程序员自己管理内存，而是通过GC来处理，GC会在合适的时间进行垃圾回收，避免无效的对象一直占用内存空间。

### 如何判断对象的无效
GC需要对无效的对象进行回收，那么如何判断对象已经是垃圾了呢。主要有两种方式：
1. 引用计数法 针对每个对象，只需要记住被引用的次数，当引用计数变为 0 时，这个对象就可以被安全地回收，不过可能有循环引用的问题，需要额外的管理才能处理。比如Python 和 PHP 等平台/语言使用的就是引用计数法
2. 可达性分析 以一系列垃圾收集根对象（GC Roots）为起始，通过引用关系向下搜索，找到所有可到达的对象形成引用链，那些不在引用链的对象就可以处理了。Java、C#等语言使用的就是可达性分析。

### 垃圾收集算法
在 JVM 中垃圾收集算法基本上有这么几种，判断是否是垃圾都是使用的可达性分析。
#### 标记—清除（Mark and Sweep）
标记—清除是最经典的垃圾收集算法。它的主要步骤有两步：
1. 标记 通过将需要清除的对象和可达对象区分开
2. 清除 将不可达对象占用的内存回收

但是这种算法会有几个问题：
1. 基本上大部分对象都是要清除的，将所有对象标记之后再清除效率太低
2. 清除之后会造成内存空间碎片话，可能导致没有合适的内存可用

#### 标记-复制算法
标记-复制算法，该算法再垃圾回收过程中会移动所有存活的对象，将存活的对象移动到另一块空闲的区域。
其优势是标记和复制可以同时进行。
不足是需要一个额外的内存区间，来存放所有的存活对象。
现代商用的虚拟机大多采用该算法来回收新生代的内存。

#### 标记-整理算法
因为老年代的特点，可能很多对象都会存活，所以不能使用标记复制-算法（对象存活高，复制效率就地）。
所以有了标记-整理算法，该算法将所有被标记的对象（存活对象），迁移到内存空间的起始处，消除了“标记—清除算法”与标记-复制算法的不足。
优势是碎片整理之后，分配新对象就很简单，不会再导致内存碎片问题
缺点就是 GC 暂停时间会增加，因为需要将所有对象复制到另一个地方，然后修改指向这些对象的引用。

### HotSpot 垃圾收集器
在HotSpot JVM中有过很多种垃圾收集器，每个收集其都有自己的特点和适用范围。
#### Serial收集器
Serial 回收器为最古老的回收器，是一个单线程的，并且他进行收集时需要STW，该回收器采用复制算法收集年轻代

使用参数：-XX:+UseSerialGC （年轻代用Serial GC，老年代用Serial Old GC）

优点：实现简单高效（与其他回收器单线程对比），对于限定单个CPU的环境中，Serial回收器没有线程交换的开销，专心做垃圾收集可以获得最高的单线程收集效率

缺点：给用户带来的延迟比较长

使用场景：单核服务器，且内存比较小（几百 MB 堆内存）

#### ParNew收集器
年轻代收集器，并行收集器，是Serial的多线程版本，一般作为CMS收集器的年轻代收集器，还可以于Serial Old GC组合使用（Jdk9之后就不能这么用了）

使用参数：-XX:UseParNewGC

优点：多线程处理可以更高效的利用CPU资源，固然比Serial更高效

缺点：在单CPU环境下，性能不如Serial

使用场景：多核服务器，作为CMS收集器的年轻代收集器

#### Parallel Scavenge收集器
Parallel Scavenge也是新生代收集器，并行回收，同样采用复制算法，它和ParNew的不同在于如下两点：
1. Parallel Scavenge目标是达到一个可控的吞吐量，可以称之为吞吐量优先的回收器
2. 自适应调节策略

优点：可控的吞吐量；自适应调节；

缺点：吞吐量高了，响应就慢

使用场景：后台运算，没有太多交互的任务。

#### Serial Old收集器
Serial收集器的老年代版本，采用标记整理算法，一般配合Serial使用。
特殊使用方式：
1. CMS失败后的后备预案

#### Paraller Old 收集器
老年代，并行收集器，采用标记-整理算法，jdk1.6之后才有，与Parallel Scavenge收集器配合使用，是jdk1.8默认的垃圾收集器。
使用参数：以下任意一组命令行参数
1. -XX:+UseParallelGC
2. -XX:+UseParallelOldGC
3. -XX:+UseParallelGC -XX:+UseParallelOldGC

优点：充分利用多和优势，达到更高的吞吐量

缺点：吞吐量高了，响应就慢

使用场景：多核，关注吞吐量优先

#### CMS收集器
CMS GC 的官方名称为 Mostly Concurrent Mark and Sweep Garbage Collector（最大并发—标记—清除—垃圾收集器），避免在老年代垃圾收集时出现长时间的卡顿

使用参数：-XX:+UseConcMarkSweepGC

优点：可以降低GC停顿导致的系统延迟

缺点：比并行GC的吞吐量差一些

使用场景： 多核，降低GC停顿导致的系统延时

#### G1收集器
Garbage First垃圾收集器（垃圾优先，哪一块的垃圾最多就优先清理它），其目标是将STW停顿的时间和分布，变成可预期且可配置的。
其特点是：
1. 堆不再分成年轻代和老年代，而是划分为多个（通常是 2048 个）可以存放对象的 小块堆区域（smaller heap regions）。每个小块，可能一会被定义成 Eden 区，一会被指定为 Survivor 区或者 Old 区。在逻辑上，所有的 Eden 区和 Survivor 区合起来就是年轻代，所有的 Old 区拼在一起那就是老年代
2. 在并发阶段估算每个小堆块存活对象的总数。构建回收集的原则是：垃圾最多的小块会被优先收集

使用参数：-XX:+UseG1GC -XX:MaxGCPauseMillis=50

优势：分代收集；可预测STW时间模型；

不足：内存占用比较高；

使用场景：面向服务端应用，具有大内存、多处理器；有低延迟需求的


#### 低延迟垃圾收集器 （暂缺）


### 垃圾收集器的选择
如果系统考虑吞吐优先，CPU 资源都用来最大程度处理业务，用 Parallel GC；
如果系统考虑低延迟有限，每次 GC 时间尽量短，用 CMS GC；
如果系统内存堆较大，同时希望整体来看平均 GC 时间可控，使用 G1 GC。

当然这只是大致的方向，在实际的工作中，还是需要实际测试才能选择合适的垃圾收集器组合。

还有几个需要注意的点：
1. 为了防止堆的扩容抖动，一般堆的初始大小和最大大小一样大
2. 使用容器时要注意容器获取的系统参数，避免出现容器认为自己使用了所有的系统资源
